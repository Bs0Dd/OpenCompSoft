local computer=computer;local component=component;local unicode=unicode;local a={}local b={tabcom=false,stordate=true}local c;for d in component.list('filesystem')do local e=component.proxy(d)if e.getLabel()=='tmpfs'then c=e;break end end;local function f(g)local h="^[%a_][%w_]*$"local i={}local j={}local function k(l,m)local n=type(l)if n=="number"then if l~=l then table.insert(j,"0/0")elseif l==math.huge then table.insert(j,"math.huge")elseif l==-math.huge then table.insert(j,"-math.huge")else table.insert(j,tostring(l))end elseif n=="string"then table.insert(j,(string.format("%q",l):gsub("\\\n","\\n")))elseif n=="nil"or n=="boolean"then table.insert(j,tostring(l))elseif n=="table"then i[l]=true;local o;local p=getmetatable(l)o=table.pack((p and p.__pairs or pairs)(l))local q=1;local r=true;table.insert(j,"{")for d,s in table.unpack(o)do if not r then table.insert(j,",")end;r=nil;local t=type(d)if t=="number"and d==q then q=q+1;k(s,m+1)else if t=="string"and string.match(d,h)then table.insert(j,d)else table.insert(j,"[")k(d,m+1)table.insert(j,"]")end;table.insert(j,"=")k(s,m+1)end end;i[l]=nil;table.insert(j,"}")else error("unsupported type: "..n)end end;k(g,1)local u=table.concat(j)return u end;local function v(w)local u,x=load("return "..w,"=data",nil,{math={huge=math.huge}})if not u then return nil,x end;local y,z=pcall(u)if not y then return nil,z end;return z end;local function A(B)local u={}for d,C in pairs(B)do u[d]=C end;return u end;local function D(E)local F={}for G in E:gmatch("[^\\/]+")do local H,I=G:find("^%.?%.$")if H then if I==2 then table.remove(F)end else table.insert(F,G)end end;return F end;local function J(E)local u=table.concat(D(E),"/")if unicode.sub(E,1,1)=="/"then return"/"..u else return u end end;local function K()if not b.stordate then return 0 end;local L='lt'local o=c.open(L,"w")c.close(o)local M=c.lastModified(L)c.remove(L)return math.ceil(M)end;local function N(O,P,Q,R)if R==nil then R=#O-1 elseif R==-1 then return true end;local q=0;local S=P;while q<R do if S[O[q+1]]==nil then return false end;S=S[O[q+1]]q=q+1 end;S[O[q+1]]=Q;return N(O,P,S,R-1)end;local function T(O,P)local q=0;local S=P;while q<#O do if S[O[q+1]]==nil then return false end;S=S[O[q+1]]q=q+1 end;return S end;local function U(P,V)V=V or 0;for W,X in pairs(P)do if type(X)=="table"then if X[1]==-1 then V=U(X,V)else V=V+X[1]end end end;return V end;local function Y(O,P,R)if R>#O then return true end;local Z={}local q=0;while q<R do table.insert(Z,O[q+1])q=q+1 end;dir=T(Z,P)if dir==false then N(Z,P,{-1,K()})end;return Y(O,P,R+1)end;local function _(a0,a1,a2)for d,a3 in pairs(a0)do if type(d)~='number'then if a3[1]==-1 then local a4=A(a2)table.insert(a4,d)local a5=T(a4,a1[1])if not a5 then return a5 end;if not _(a5,a1,a4)then return false end else for W,a6 in pairs(a0[3])do table.insert(a1[2],a6)end end end end;N(a2,a1[1],nil)return true end;local function a7(a8,a9)local q=0;local aa=0;while q<#a8 do q=q+1;local ab=aa;aa=aa+a8[q][2]-a8[q][1]if ab<=a9 and aa>=a9 then return q end end;return false end;local function ac(ad,ae,a0)local aa=0;while ad<=ae do aa=aa+a0[3][ad][2]-a0[3][ad][1]ad=ad+1 end;return aa end;local function af(ag,ah)if ag[1]<ah[1]then return true else return false end end;local ai,aj;if computer.getArchitecture()=="Lua 5.3"then ai,aj=load([[return function(a)local b,c=1,{}local d=''local function e()for f=18,3,-1 do local g=string.sub(a,b,b+f-1)local h=string.find(d,g,1,true)if h then return h,g end end end;while b<=#a do local i,j=0,{}for f=0,7 do if b<=#a then local h,g=e()if h and#g>=3 then local k=h-1<<4|#g-3;j[#j+1]=string.pack('>I2',k)else i=i|(1<<f)g=string.sub(a,b,b)j[#j+1]=g end;d=string.sub(d..g,-4096)b=b+#g else break end end;if#j>0 then c[#c+1]=string.char(i)c[#c+1]=table.concat(j)end end;return table.concat(c)end,function(a)local b,c=1,{}local d=''while b<=#a do local i=string.byte(a,b)b=b+1;for f=1,8 do local g=nil;if i&1~=0 then if b<=#a then g=string.sub(a,b,b)b=b+1 end else if b+1<=#a then local k=string.unpack('>I2',a,b)b=b+2;local h=k>>4+1;local l=k&15+3;g=string.sub(d,h,h+l-1)end end;i=i>>1;if g then c[#c+1]=g;d=string.sub(d..g,-4096)end end end;return table.concat(c)end]])()end;local ak={}function ak.proxy(al)local am=false;for d,s in component.list("tape_drive")do if d==al and s=="tape_drive"then am=true;break end end;if not am then error("No such component",2)end;local an;component.invoke(al,"seek",-math.huge)local ao={}ao.type="filesystem"ao.address=al:gsub("-","").."-tap"ao.isReady=function()return component.invoke(al,"isReady")end;ao.setDriveProperty=function(ap,g)checkArg(1,ap,"string")checkArg(2,g,"number","string","boolean")if b[ap]==nil then return nil,'Invalid property'end;b[ap]=g;return true end;ao.getDriveProperty=function(ap)checkArg(1,ap,"string")if b[ap]==nil then return nil,'Invalid property'end;return b[ap]end;ao.getTable=function()if not ao.isReady()then error('Device is not ready')end;component.invoke(al,"seek",-math.huge)local aq=component.invoke(al,"read",8192)local ar;if aq:sub(0,2)=="{{"then ar=aq:match("[^\0]+")elseif aq:sub(3,4)=="\120\156"then if not component.isAvailable('data')then error('inflate: Data card required')end;ar=component.data.inflate(string.unpack('s2',aq))else if not aj then error('LZSS decompression: Lua 5.3 required')end;ar=aj(string.unpack('s2',aq))end;if not ar or ar==""then error('FAT corrupted: table not found')end;local as,at=v(ar)if not as then error('FAT corrupted: '..(at or'unknown reason'))else return as end end;ao.setTable=function(au)checkArg(1,au,"table")if not ao.isReady()then error('Device is not ready')end;local av=f(au)if b.tabcom==1 then if not ai then error('LZSS compression: Lua 5.3 required')end;av=string.pack('s2',ai(av))elseif b.tabcom==2 then if not component.isAvailable('data')then error('deflate: Data card required')end;av=string.pack('s2',component.data.deflate(av))end;if#av>8192 then return nil,'Not enough space for FAT'end;component.invoke(al,"seek",-math.huge)component.invoke(al,"write",string.rep("\0",8192))component.invoke(al,"seek",-math.huge)component.invoke(al,"write",av)return#av end;ao.format=function(aw)aw=aw or false;checkArg(1,aw,"boolean")if not ao.isReady()then error('Device is not ready')end;local ax=component.invoke(al,"getSize")if not aw then component.invoke(al,"seek",-math.huge)local ay=string.rep("\0",8192)for q=1,ax+8191,8192 do component.invoke(al,"write",ay)end end;local az,at=ao.setTable({{},{{8192,math.ceil(ax)-1}}})if not az then return az,at else return true end end;ao.isDirectory=function(E)checkArg(1,E,"string")if not ao.isReady()then error('Device is not ready')end;E=J(E)if E==''then return true end;local a2=D(E)local a1=ao.getTable()local aA=T(a2,a1[1])if type(aA)~='table'then return false end;if aA[1]==-1 then return true else return false end end;ao.lastModified=function(E)checkArg(1,E,"string")E=J(E)if not ao.isReady()then error('Device is not ready')end;local a1=ao.getTable()local a2=D(E)local a0=T(a2,a1[1])if not a0 then return 0 end;return a0[2]end;ao.list=function(E)checkArg(1,E,"string")E=J(E)if not ao.isReady()then error('Device is not ready')end;local a1=ao.getTable()local a2=D(E)local aB=T(a2,a1[1])if aB==false then return nil,'no such file or directory: '..E end;local aA={}if aB[1]~=-1 and#a2~=0 then return{a2[#a2],n=1}end;for d,C in pairs(aB)do if type(d)~='number'then if C[1]==-1 then table.insert(aA,d..'/')else table.insert(aA,d)end end end;aA.n=#aA;return aA end;ao.spaceTotal=function()if not ao.isReady()then error('Device is not ready')end;return component.invoke(al,"getSize")-8193 end;ao.open=function(E,aC)aC=aC or'r'checkArg(1,E,"string")checkArg(2,aC,"string")if not ao.isReady()then error('Device is not ready')end;local aD;local a1=ao.getTable()local a2=D(E)if aC~="r"and aC~="rb"and aC~="w"and aC~="wb"and aC~="a"and aC~="ab"then error("unsupported mode",2)end;local aE=true;while aE do aD=math.random(1000000000,9999999999)if a[aD]==nil then if aC=="r"or aC=="rb"then local aF=T(a2,a1[1])if not aF or aF[1]==-1 then return nil,E end;a[aD]={seek=0,mode='r',path=a2}elseif aC=="w"or aC=="wb"then a[aD]={seek=0,mode='w',path=a2}local aF=T(a2,a1[1])if aF then for W,aG in pairs(aF[3])do table.insert(a1[2],aG)end;table.sort(a1[2],af)local aH=1;while aH<#a1[2]do if a1[2][aH][2]==a1[2][aH+1][1]then a1[2][aH][2]=a1[2][aH+1][2]table.remove(a1[2],aH+1)else aH=aH+1 end end elseif#a1[2]==0 then return nil,"not enough space"end;if not N(a2,a1[1],{0,K(),{}})then return false end elseif aC=="a"or aC=="ab"then local aF=T(a2,a1[1])local aI;if not aF then if not N(a2,a1[1],{0,K(),{}})then return false end else aI=aF[1]+1 end;a[aD]={seek=aI,mode='a',path=a2}end;aE=false end end;if aC=="a"or aC=="ab"or aC=="w"or aC=="wb"then local az,at=ao.setTable(a1)if not az then return az,at else return aD end else return aD end end;ao.remove=function(E)checkArg(1,E,"string")if not ao.isReady()then error('Device is not ready')end;E=J(E)if E==''then return false end;local a1=ao.getTable()local a2=D(E)local a0=T(a2,a1[1],true)if a0==false then return false end;if a0[1]==-1 then _(a0,a1,a2)else for W,a6 in pairs(a0[3])do table.insert(a1[2],a6)end;N(a2,a1[1],nil)end;table.sort(a1[2],af)local aH=1;while aH<#a1[2]do if a1[2][aH][2]==a1[2][aH+1][1]then a1[2][aH][2]=a1[2][aH+1][2]table.remove(a1[2],aH+1)else aH=aH+1 end end;local az,at=ao.setTable(a1)if not az then return az,at else return true end end;ao.rename=function(E,aJ)checkArg(1,E,"string")checkArg(1,aJ,"string")if not ao.isReady()then error('Device is not ready')end;E=J(E)local a1=ao.getTable()local a2=D(E)local aK=D(aJ)local a0=T(a2,a1[1])local aL=T(aK,a1[1])if not a0 or aL then return false end;if a0[1]~=-1 then aK=D(aJ)end;N(a2,a1[1],nil)N(aK,a1[1],a0)if not N(aK,a1[1],a0)then return false end;local az,at=ao.setTable(a1)if not az then return az,at else return true end end;ao.read=function(aM,aN)aN=aN or 1;checkArg(1,aM,"number")checkArg(2,aN,"number")if not ao.isReady()then error('Device is not ready')end;if a[aM]==nil or a[aM].mode~="r"then return nil,"bad file descriptor"end;local a1=ao.getTable()local a0=T(a[aM].path,a1[1])if not a0 then a[aM]=nil;return nil,"bad file descriptor"end;if a0[1]==0 or a0[1]<a[aM].seek+1 then return nil end;if a0[1]>=a[aM].seek+1 and a0[1]<a[aM].seek+aN then aN=a0[1]-a[aM].seek end;component.invoke(al,"seek",-math.huge)local aO=a7(a0[3],a[aM].seek)local aP=a7(a0[3],a[aM].seek+aN)if not aP then aP=#a0[3]end;component.invoke(al,"seek",a0[3][aO][1]+a[aM].seek-ac(1,aO-1,a0))local w=component.invoke(al,"read",a0[3][aO][2]-a0[3][aO][1])aO=aO+1;while aO<aP+1 do component.invoke(al,"seek",-math.huge)component.invoke(al,"seek",a0[3][aO][1])w=w..component.invoke(al,"read",a0[3][aO][2]-a0[3][aO][1])aO=aO+1 end;w=w:sub(0,aN)a[aM].seek=a[aM].seek+#w;return w end;ao.close=function(aM)checkArg(1,aM,"number")if not ao.isReady()then error('Device is not ready')end;if a[aM]==nil then return nil,"bad file descriptor"end;a[aM]=nil end;ao.getLabel=function()if not ao.isReady()then error('Device is not ready')end;return component.invoke(al,"getLabel")end;ao.seek=function(aM,aQ,aR)checkArg(1,aM,"number")checkArg(2,aQ,"string")checkArg(3,aR,"number")if not ao.isReady()then error('Device is not ready')end;if a[aM]==nil then return nil,"bad file descriptor"end;if aQ~="set"and aQ~="cur"and aQ~="end"then error("invalid mode",2)end;if aR<0 then return nil,"Negative seek offset"end;local aS;if aQ=="set"then aS=aR elseif aQ=="cur"then aS=a[aM].seek+aR elseif aQ=="end"then aS=component.invoke(al,"getSize")+aR-1 end;a[aM].seek=math.min(math.max(aS,0),component.invoke(al,"getSize")-1)return a[aM].seek end;ao.size=function(E)checkArg(1,E,"string")if not ao.isReady()then error('Device is not ready')end;E=J(E)if E==''then return 0 end;local a1=ao.getTable()local a2=D(E)local a0=T(a2,a1[1])if not a0 or a0[1]==-1 then return 0 end;return a0[1]end;ao.isReadOnly=function()if not ao.isReady()then error('Device is not ready')end;return false end;ao.setLabel=function(aT)if not ao.isReady()then error('Device is not ready')end;component.invoke(al,"setLabel",aT)return aT end;ao.makeDirectory=function(E)checkArg(1,E,"string")if not ao.isReady()then error('Device is not ready')end;E=J(E)local a1=ao.getTable()local a2=D(E)Y(a2,a1[1],1)local az,at=ao.setTable(a1)if not az then return az,at else return true end end;ao.exists=function(E)checkArg(1,E,"string")if not ao.isReady()then error('Device is not ready')end;E=J(E)if E==''then return true end;local a2=D(E)local a1=ao.getTable()local aA=T(a2,a1[1])if aA then return true else return aA end end;ao.spaceUsed=function()if not ao.isReady()then error('Device is not ready')end;return U(ao.getTable()[1])end;ao.write=function(aM,w)checkArg(1,aM,"number")checkArg(2,w,"string")if not ao.isReady()then error('Device is not ready')end;if a[aM]==nil or a[aM].mode=="r"then return nil,"bad file descriptor"end;local a1=ao.getTable()if#a1[2]==0 then return nil,"not enough space"end;local a2=a[aM].path;local a0=T(a2,a1[1])a[aM].seek=a[aM].seek+#w;if a[aM].seek>a0[1]or#a0[3]==0 then a0[1]=a0[1]+#w;while true do if#a1[2]==0 then a0[1]=ac(1,#a0[3],a0)local az,at=ao.setTable(a1)if not az then return az,at else return true end elseif a1[2][1][2]-a1[2][1][1]<#w then table.insert(a0[3],{a1[2][1][1],a1[2][1][2]})component.invoke(al,"seek",-math.huge)component.invoke(al,"seek",a1[2][1][1])component.invoke(al,"write",w:sub(0,a1[2][1][2]-a1[2][1][1]))w=w:sub(a1[2][1][2]-a1[2][1][1]+1)table.remove(a1[2],1)else table.insert(a0[3],{a1[2][1][1],a1[2][1][1]+#w})component.invoke(al,"seek",-math.huge)component.invoke(al,"seek",a1[2][1][1])component.invoke(al,"write",w)if a1[2][1][1]+#w==a1[2][1][2]then table.remove(a1[2],1)else a1[2][1][1]=a1[2][1][1]+#w end;break end end elseif a[aM].seek+#w>a0[1]then a0[1]=a[aM].seek+#w;local aO=a7(a0[3],a[aM].seek)local aP=#a0[3]if not aP then aP=#a0[3]end;component.invoke(al,"seek",a0[3][aO][1]+a[aM].seek-ac(1,aO-1,a0))component.invoke(al,"write",w:sub(0,a0[3][aO][2]-a0[3][aO][1]))w=w:sub(a0[3][aO][2]-a0[3][aO][1])aO=aO+1;while aO<aP+1 do component.invoke(al,"seek",-math.huge)component.invoke(al,"seek",a0[3][aO][1])component.invoke(al,"write",w:sub(0,a0[3][aO][2]-a0[3][aO][1]))w=w:sub(a0[3][aO][2]-a0[3][aO][1]+1)aO=aO+1 end;while true do if#a1[2]==0 then a0[1]=ac(1,#a0[3],a0)local az,at=ao.setTable(a1)if not az then return az,at else return true end elseif a1[2][1][2]-a1[2][1][1]<#w then table.insert(a0[3],{a1[2][1][1],a1[2][1][2]})component.invoke(al,"seek",-math.huge)component.invoke(al,"seek",a1[2][1][1])component.invoke(al,"write",w:sub(0,a1[2][1][2]-a1[2][1][1]))w=w:sub(a1[2][1][2]-a1[2][1][1]+1)table.remove(a1[2],1)else table.insert(a0[3],{a1[2][1][1],a1[2][1][1]+#w})component.invoke(al,"seek",-math.huge)component.invoke(al,"seek",a1[2][1][1])component.invoke(al,"write",w)if a1[2][1][1]+#w==a1[2][1][2]then table.remove(a1[2],1)else a1[2][1][1]=a1[2][1][1]+#w end;break end end else local aO=a7(a0[3],a[aM].seek)local aP=a7(a0[3],a[aM].seek+#w)if not aP then aP=#a0[3]end;component.invoke(al,"seek",a0[3][aO][1]+a[aM].seek-ac(1,aO-1,a0))component.invoke(al,"write",w:sub(0,a0[3][aO][2]-a0[3][aO][1]))w=w:sub(a0[3][aO][2]-a0[3][aO][1])aO=aO+1;while aO<aP+1 do component.invoke(al,"seek",-math.huge)component.invoke(al,"seek",a0[3][aO][1])component.invoke(al,"write",w:sub(0,a0[3][aO][2]-a0[3][aO][1]))w=w:sub(a0[3][aO][2]-a0[3][aO][1]+1)aO=aO+1 end end;local aH=1;while aH<#a0[3]do if a0[3][aH][2]==a0[3][aH+1][1]then a0[3][aH][2]=a0[3][aH+1][2]table.remove(a0[3],aH+1)else aH=aH+1 end end;N(a2,a1[1],a0)local az,at=ao.setTable(a1)if not az then return az,at else return true end end;return ao end;local aU=ak.proxy(component.list('tape_drive')())local aV=component.proxy;function component.proxy(al)checkArg(1,al,"string")if aU.address==al then return aU end;return aV(al)end;local aW=component.list;function component.list(aX,aY)local aZ=aW(aX,aY)if aX==nil or aY and aX=='filesystem'or not aY and('filesystem'):find(aX,nil,true)then aZ[aU.address]='filesystem'end;return aZ end;local a_=component.invoke;function component.invoke(al,b0,...)checkArg(1,al,"string")checkArg(2,b0,"string")if aU.address==al then if aU[b0]==nil then error("no such method",2)end;return aU[b0](...)end;return a_(al,b0,...)end