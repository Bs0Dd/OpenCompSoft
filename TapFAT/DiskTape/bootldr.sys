local computer=computer;local component=component;local unicode=unicode;local a={}local b;for c in component.list('filesystem')do local d=component.proxy(c)if d.getLabel()=='tmpfs'then b=d;break end end;local function e(f)local g="^[%a_][%w_]*$"local h={}local i={}local function j(k,l)local m=type(k)if m=="number"then if k~=k then table.insert(i,"0/0")elseif k==math.huge then table.insert(i,"math.huge")elseif k==-math.huge then table.insert(i,"-math.huge")else table.insert(i,tostring(k))end elseif m=="string"then table.insert(i,(string.format("%q",k):gsub("\\\n","\\n")))elseif m=="nil"or m=="boolean"then table.insert(i,tostring(k))elseif m=="table"then h[k]=true;local n;local o=getmetatable(k)n=table.pack((o and o.__pairs or pairs)(k))local p=1;local q=true;table.insert(i,"{")for c,r in table.unpack(n)do if not q then table.insert(i,",")end;q=nil;local s=type(c)if s=="number"and c==p then p=p+1;j(r,l+1)else if s=="string"and string.match(c,g)then table.insert(i,c)else table.insert(i,"[")j(c,l+1)table.insert(i,"]")end;table.insert(i,"=")j(r,l+1)end end;h[k]=nil;table.insert(i,"}")else error("unsupported type: "..m,0)end end;j(f,1)local t=table.concat(i)return t end;local function u(v)local t,w=load("return "..v,"=data",nil,{math={huge=math.huge}})if not t then return nil,w end;local x,y=pcall(t)if not x then return nil,y end;return y end;local function z(A)local t={}for c,B in pairs(A)do t[c]=B end;return t end;local function C(D)local E={}for F in D:gmatch("[^\\/]+")do local G,H=F:find("^%.?%.$")if G then if H==2 then table.remove(E)end else table.insert(E,F)end end;return E end;local function I(D)local t=table.concat(C(D),"/")if unicode.sub(D,1,1)=="/"then return"/"..t else return t end end;local function J(K)if not K.stordate then return 0 end;local L='lt'local n=b.open(L,"w")b.close(n)local M=b.lastModified(L)b.remove(L)return math.ceil(M)end;local function N(O,P,Q,R)if#O<1 then return P end;local p=1;local S=P;while p<#O do if S[O[p]]==nil then return false end;S=S[O[p]]p=p+1 end;if not Q then return S[O[p]]or false else S[O[p]]=R;return true end end;local function T(O,P,R)return N(O,P,true,R)end;local function U(P,V)V=V or 0;for W,X in pairs(P)do if type(X)=="table"then if X[1]==-1 then V=U(X,V)else V=V+X[1]end end end;return V end;local function Y(O,P,K,Z)if Z>#O then return true end;local _={}local p=0;while p<Z do table.insert(_,O[p+1])p=p+1 end;dir=N(_,P)if dir==false then T(_,P,{-1,J(K)})end;return Y(O,P,K,Z+1)end;local function a0(a1,a2,a3)for c,a4 in pairs(a1)do if type(c)~='number'then if a4[1]==-1 then local a5=z(a3)table.insert(a5,c)local a6=N(a5,a2[1])if not a6 then return a6 end;if not a0(a6,a2,a5)then return false end else for W,a7 in pairs(a4[3])do table.insert(a2[2],a7)end end end end;T(a3,a2[1],nil)return true end;local function a8(a9,aa)local p=0;local ab=0;while p<#a9 do p=p+1;local ac=ab;ab=ab+a9[p][2]if ac<=aa and ab>=aa then return p end end;return false end;local function ad(ae,af,a1)local ab=0;while ae<=af do ab=ab+a1[3][ae][2]ae=ae+1 end;return ab end;local function ag(ah,ai)if ah[1]<ai[1]then return true else return false end end;local function aj(a1,a2,ak,v,al)while true do if#a2[2]==0 then a1[1]=ad(1,#a1[3],a1)local am,an=ak(a2)if not am then return am,an else return true end elseif a2[2][1][2]<#v then table.insert(a1[3],{a2[2][1][1],a2[2][1][2]})component.invoke(al,"seek",-math.huge)component.invoke(al,"seek",a2[2][1][1])component.invoke(al,"write",v:sub(0,a2[2][1][2]))v=v:sub(a2[2][1][2]+1)table.remove(a2[2],1)else table.insert(a1[3],{a2[2][1][1],#v})component.invoke(al,"seek",-math.huge)component.invoke(al,"seek",a2[2][1][1])component.invoke(al,"write",v)if#v==a2[2][1][2]then table.remove(a2[2],1)else a2[2][1][1]=a2[2][1][1]+#v;a2[2][1][2]=a2[2][1][2]-#v end;break end end;return 1 end;local function ao(a1,v,al,ap)local aq=a8(a1[3],ap)local ar=#a1[3]if not ar then ar=#a1[3]end;component.invoke(al,"seek",a1[3][aq][1]+ap-ad(1,aq-1,a1))component.invoke(al,"write",v:sub(0,a1[3][aq][2]))v=v:sub(a1[3][aq][2])aq=aq+1;while aq<ar+1 do component.invoke(al,"seek",-math.huge)component.invoke(al,"seek",a1[3][aq][1])component.invoke(al,"write",v:sub(0,a1[3][aq][2]))v=v:sub(a1[3][aq][2])aq=aq+1 end end;local as,at;if computer.getArchitecture()~="Lua 5.2"then as,at=load([[return function(a)local b,c=1,{}local d=''local function e()for f=18,3,-1 do local g=string.sub(a,b,b+f-1)local h=string.find(d,g,1,true)if h then return h,g end end end;while b<=#a do local i,j=0,{}for f=0,7 do if b<=#a then local h,g=e()if h and#g>=3 then local k=h-1<<4|#g-3;j[#j+1]=string.pack('>I2',k)else i=i|(1<<f)g=string.sub(a,b,b)j[#j+1]=g end;d=string.sub(d..g,-4096)b=b+#g else break end end;if#j>0 then c[#c+1]=string.char(i)c[#c+1]=table.concat(j)end end;return table.concat(c)end,function(a)local b,c=1,{}local d=''while b<=#a do local i=string.byte(a,b)b=b+1;for f=1,8 do local g=nil;if i&1~=0 then if b<=#a then g=string.sub(a,b,b)b=b+1 end else if b+1<=#a then local k=string.unpack('>I2',a,b)b=b+2;local h=k>>4+1;local l=k&15+3;g=string.sub(d,h,h+l-1)end end;i=i>>1;if g then c[#c+1]=g;d=string.sub(d..g,-4096)end end end;return table.concat(c)end]])()end;local au={}function au.proxy(al)local av=false;for c,r in component.list("tape_drive")do if c==al and r=="tape_drive"then av=true;break end end;if not av then error("No such component",2)end;local K={tabcom=false,stordate=true}component.invoke(al,"seek",-math.huge)local aw={}aw.type="filesystem"aw.address=al:gsub("-","").."-tap"aw.isReady=function()return component.invoke(al,"isReady")end;aw.setDriveProperty=function(ax,f)checkArg(1,ax,"string")checkArg(2,f,"number","string","boolean")if K[ax]==nil then return nil,'Invalid property'end;K[ax]=f;return true end;aw.getDriveProperty=function(ax)checkArg(1,ax,"string")if K[ax]==nil then return nil,'Invalid property'end;return K[ax]end;aw.getTable=function()if not aw.isReady()then error('Device is not ready',0)end;component.invoke(al,"seek",-math.huge)local ay=component.invoke(al,"read",8192)local az;if ay:sub(0,2)=="{{"then az=ay:match("[^\0]+")elseif ay:sub(3,4)=="\120\156"then if not component.isAvailable('data')then error('inflate: Data card required',0)end;if not string.unpack then error('string.unpack: Lua 5.3 or newer required',0)end;az=component.data.inflate(string.unpack('s2',ay))elseif ay:sub(0,2)~="\0\0"then if not at then error('LZSS decompression: Lua 5.3 or newer required',0)end;az=at(string.unpack('s2',ay))end;if not az or az==""then error('FAT corrupted: table not found',0)end;local aA,an=u(az)if not aA then error('FAT corrupted: '..(an or'unknown reason'),0)else return aA end end;aw.setTable=function(aB)checkArg(1,aB,"table")if not aw.isReady()then error('Device is not ready',0)end;local aC=e(aB)if K.tabcom==1 then if not as then error('LZSS compression: Lua 5.3 or newer required',0)end;aC=string.pack('s2',as(aC))elseif K.tabcom==2 then if not component.isAvailable('data')then error('deflate: Data card required',0)end;if not string.pack then error('string.pack: Lua 5.3 or newer required',0)end;aC=string.pack('s2',component.data.deflate(aC))end;if#aC>8192 then return nil,'Not enough space for FAT'end;if#aC~=8192 then aC=aC.."\0"end;component.invoke(al,"seek",-math.huge)component.invoke(al,"write",aC)return#aC end;aw.format=function(aD)aD=aD or false;checkArg(1,aD,"boolean")if not aw.isReady()then error('Device is not ready',0)end;local aE=component.invoke(al,"getSize")if not aD then component.invoke(al,"seek",-math.huge)local aF=string.rep("\0",8192)for p=1,aE+8191,8192 do component.invoke(al,"write",aF)end end;local am,an=aw.setTable({{},{{8192,math.ceil(aE)-8192}}})if not am then return am,an else if component.invoke(al,"getLabel")==""then component.invoke(al,"setLabel","TapFAT Data Tape")end;return true end end;aw.isDirectory=function(D)checkArg(1,D,"string")if not aw.isReady()then error('Device is not ready',0)end;D=I(D)if D==''then return true end;local a3=C(D)local a2=aw.getTable()local aG=N(a3,a2[1])if type(aG)~='table'then return false end;if aG[1]==-1 then return true else return false end end;aw.lastModified=function(D)checkArg(1,D,"string")D=I(D)if not aw.isReady()then error('Device is not ready',0)end;local a2=aw.getTable()local a3=C(D)local a1=N(a3,a2[1])if not a1 then return 0 end;return a1[2]or 0 end;aw.list=function(D)checkArg(1,D,"string")D=I(D)if not aw.isReady()then error('Device is not ready',0)end;local a2=aw.getTable()local a3=C(D)local aH=N(a3,a2[1])if aH==false then return nil,'no such file or directory: '..D end;local aG={}if aH[1]~=-1 and#a3~=0 then return{a3[#a3],n=1}end;for c,B in pairs(aH)do if type(c)~='number'then if B[1]==-1 then table.insert(aG,c..'/')else table.insert(aG,c)end end end;aG.n=#aG;return aG end;aw.spaceTotal=function()if not aw.isReady()then error('Device is not ready',0)end;return component.invoke(al,"getSize")-8193 end;aw.open=function(D,aI)aI=aI or'r'checkArg(1,D,"string")checkArg(2,aI,"string")if not aw.isReady()then error('Device is not ready',0)end;local aJ;local a2=aw.getTable()local a3=C(D)if aI~="r"and aI~="rb"and aI~="w"and aI~="wb"and aI~="a"and aI~="ab"then error("unsupported mode",2)end;local aK=true;while aK do aJ=math.random(1000000000,9999999999)if a[aJ]==nil then if aI=="r"or aI=="rb"then local aL=N(a3,a2[1])if not aL or aL[1]==-1 then return nil,D end;a[aJ]={seek=0,mode='r',path=a3}elseif aI=="w"or aI=="wb"then a[aJ]={seek=0,mode='w',path=a3}local aL=N(a3,a2[1])if aL then for W,aM in pairs(aL[3])do table.insert(a2[2],aM)end;table.sort(a2[2],ag)local aN=1;while aN<#a2[2]do if a2[2][aN][1]+a2[2][aN][2]==a2[2][aN+1][1]then a2[2][aN][2]=a2[2][aN][2]+a2[2][aN+1][2]table.remove(a2[2],aN+1)else aN=aN+1 end end elseif#a2[2]==0 then return nil,"not enough space"end;if not T(a3,a2[1],{0,J(K),{}})then return false end elseif aI=="a"or aI=="ab"then local aL=N(a3,a2[1])local aO;if not aL then if not T(a3,a2[1],{0,J(K),{}})then return false end else aO=aL[1]+1 end;a[aJ]={seek=aO,mode='a',path=a3}end;aK=false end end;if aI=="a"or aI=="ab"or aI=="w"or aI=="wb"then local am,an=aw.setTable(a2)if not am then return am,an else return aJ end else return aJ end end;aw.remove=function(D)checkArg(1,D,"string")if not aw.isReady()then error('Device is not ready',0)end;D=I(D)if D==''then return false end;local a2=aw.getTable()local a3=C(D)local a1=N(a3,a2[1])if a1==false then return false end;if a1[1]==-1 then a0(a1,a2,a3)else for W,a7 in pairs(a1[3])do table.insert(a2[2],a7)end;T(a3,a2[1],nil)end;table.sort(a2[2],ag)local aN=1;while aN<#a2[2]do if a2[2][aN][1]+a2[2][aN][2]==a2[2][aN+1][1]then a2[2][aN][2]=a2[2][aN][2]+a2[2][aN+1][2]table.remove(a2[2],aN+1)else aN=aN+1 end end;local am,an=aw.setTable(a2)if not am then return am,an else return true end end;aw.rename=function(D,aP)checkArg(1,D,"string")checkArg(1,aP,"string")if not aw.isReady()then error('Device is not ready',0)end;D=I(D)local a2=aw.getTable()local a3=C(D)local aQ=C(aP)local a1=N(a3,a2[1])local aR=N(aQ,a2[1])if not a1 or aR then return false end;if a1[1]~=-1 then aQ=C(aP)end;T(a3,a2[1],nil)if not T(aQ,a2[1],a1)then return false end;local am,an=aw.setTable(a2)if not am then return am,an else return true end end;aw.read=function(aS,aT)aT=aT or 1;checkArg(1,aS,"number")checkArg(2,aT,"number")if not aw.isReady()then error('Device is not ready',0)end;if a[aS]==nil or a[aS].mode~="r"then return nil,"bad file descriptor"end;local a2=aw.getTable()local a1=N(a[aS].path,a2[1])if not a1 then a[aS]=nil;return nil,"bad file descriptor"end;if a1[1]==0 or a1[1]<a[aS].seek+1 then return nil end;if a1[1]>=a[aS].seek+1 and a1[1]<a[aS].seek+aT then aT=a1[1]-a[aS].seek end;component.invoke(al,"seek",-math.huge)local aq=a8(a1[3],a[aS].seek)local ar=a8(a1[3],a[aS].seek+aT)if not ar then ar=#a1[3]end;component.invoke(al,"seek",a1[3][aq][1]+a[aS].seek-ad(1,aq-1,a1))local v=component.invoke(al,"read",a1[3][aq][2])aq=aq+1;while aq<ar+1 do component.invoke(al,"seek",-math.huge)component.invoke(al,"seek",a1[3][aq][1])v=v..component.invoke(al,"read",a1[3][aq][2])aq=aq+1 end;v=v:sub(0,aT)a[aS].seek=a[aS].seek+#v;return v end;aw.close=function(aS)checkArg(1,aS,"number")if not aw.isReady()then error('Device is not ready',0)end;if a[aS]==nil then return nil,"bad file descriptor"end;a[aS]=nil end;aw.getLabel=function()if not aw.isReady()then error('Device is not ready',0)end;return component.invoke(al,"getLabel")end;aw.seek=function(aS,aU,aV)checkArg(1,aS,"number")checkArg(2,aU,"string")checkArg(3,aV,"number")if not aw.isReady()then error('Device is not ready',0)end;if a[aS]==nil then return nil,"bad file descriptor"end;if aU~="set"and aU~="cur"and aU~="end"then error("invalid mode",2)end;if aV<0 then return nil,"Negative seek offset"end;local aW;if aU=="set"then aW=aV elseif aU=="cur"then aW=a[aS].seek+aV elseif aU=="end"then aW=component.invoke(al,"getSize")+aV-1 end;a[aS].seek=math.min(math.max(aW,0),component.invoke(al,"getSize")-1)return a[aS].seek end;aw.size=function(D)checkArg(1,D,"string")if not aw.isReady()then error('Device is not ready',0)end;D=I(D)if D==''then return 0 end;local a2=aw.getTable()local a3=C(D)local a1=N(a3,a2[1])if not a1 or a1[1]==-1 then return 0 end;return a1[1]end;aw.isReadOnly=function()if not aw.isReady()then error('Device is not ready',0)end;return false end;aw.setLabel=function(aX)if not aw.isReady()then error('Device is not ready',0)end;component.invoke(al,"setLabel",aX)return aX end;aw.makeDirectory=function(D)checkArg(1,D,"string")if not aw.isReady()then error('Device is not ready',0)end;D=I(D)local a2=aw.getTable()local a3=C(D)Y(a3,a2[1],K,1)local am,an=aw.setTable(a2)if not am then return am,an else return true end end;aw.exists=function(D)checkArg(1,D,"string")if not aw.isReady()then error('Device is not ready',0)end;D=I(D)if D==''then return true end;local a3=C(D)local a2=aw.getTable()local aG=N(a3,a2[1])if aG then return true else return aG end end;aw.spaceUsed=function()if not aw.isReady()then error('Device is not ready',0)end;return U(aw.getTable()[1])end;aw.write=function(aS,v)checkArg(1,aS,"number")checkArg(2,v,"string")if not aw.isReady()then error('Device is not ready',0)end;if a[aS]==nil or a[aS].mode=="r"then return nil,"bad file descriptor"end;local a2=aw.getTable()if#a2[2]==0 then return nil,"not enough space"end;local a3=a[aS].path;local a1=N(a3,a2[1])a[aS].seek=a[aS].seek+#v;if a[aS].seek>a1[1]or#a1[3]==0 then a1[1]=a1[1]+#v;local am,an=aj(a1,a2,aw.setTable,v,al)if not am then return am,an elseif am~=1 then return true end elseif a[aS].seek+#v>a1[1]then a1[1]=a[aS].seek+#v;ao(a1,v,al,a[aS].seek)local am,an=aj(a1,a2,aw.setTable,v,al)if not am then return am,an elseif am~=1 then return true end else ao(a1,v,al,a[aS].seek)end;local aN=1;while aN<#a1[3]do if a1[3][aN][1]+a1[3][aN][2]==a1[3][aN+1][1]then a1[3][aN][2]=a1[3][aN][2]+a1[3][aN+1][2]table.remove(a1[3],aN+1)else aN=aN+1 end end;T(a3,a2[1],a1)local am,an=aw.setTable(a2)if not am then return am,an else return true end end;return aw end;local aY=au.proxy(component.list('tape_drive')())local aZ=component.proxy;function component.proxy(al)checkArg(1,al,"string")if aY.address==al then return aY end;return aZ(al)end;local a_=component.list;function component.list(b0,b1)local b2=a_(b0,b1)if b0==nil or b1 and b0=='filesystem'or not b1 and('filesystem'):find(b0,nil,true)then b2[aY.address]='filesystem'end;return b2 end;local b3=component.invoke;function component.invoke(al,b4,...)checkArg(1,al,"string")checkArg(2,b4,"string")if aY.address==al then if aY[b4]==nil then error("no such method",2)end;return aY[b4](...)end;return b3(al,b4,...)end
