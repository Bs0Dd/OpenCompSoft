local computer=computer;local component=component;local unicode=unicode;local a={}local b={tabcom=false,stordate=true}local c;for d in component.list('filesystem')do local e=component.proxy(d)if e.getLabel()=='tmpfs'then c=e;break end end;local function f(g)local h="^[%a_][%w_]*$"local i={}local j={}local function k(l,m)local n=type(l)if n=="number"then if l~=l then table.insert(j,"0/0")elseif l==math.huge then table.insert(j,"math.huge")elseif l==-math.huge then table.insert(j,"-math.huge")else table.insert(j,tostring(l))end elseif n=="string"then table.insert(j,(string.format("%q",l):gsub("\\\n","\\n")))elseif n=="nil"or n=="boolean"then table.insert(j,tostring(l))elseif n=="table"then i[l]=true;local o;local p=getmetatable(l)o=table.pack((p and p.__pairs or pairs)(l))local q=1;local r=true;table.insert(j,"{")for d,s in table.unpack(o)do if not r then table.insert(j,",")end;r=nil;local t=type(d)if t=="number"and d==q then q=q+1;k(s,m+1)else if t=="string"and string.match(d,h)then table.insert(j,d)else table.insert(j,"[")k(d,m+1)table.insert(j,"]")end;table.insert(j,"=")k(s,m+1)end end;i[l]=nil;table.insert(j,"}")else error("unsupported type: "..n)end end;k(g,1)local u=table.concat(j)return u end;local function v(w)local u,x=load("return "..w,"=data",nil,{math={huge=math.huge}})if not u then return nil,x end;local y,z=pcall(u)if not y then return nil,z end;return z end;local function A(B)local u={}for d,C in pairs(B)do u[d]=C end;return u end;local function D(E)local F={}for G in E:gmatch("[^\\/]+")do local H,I=G:find("^%.?%.$")if H then if I==2 then table.remove(F)end else table.insert(F,G)end end;return F end;local function J(E)local u=table.concat(D(E),"/")if unicode.sub(E,1,1)=="/"then return"/"..u else return u end end;local function K()if not b.stordate then return 0 end;local L='lt'local o=c.open(L,"w")c.close(o)local M=c.lastModified(L)c.remove(L)return math.ceil(M)end;local function N(O,P,Q)if#O<1 then return P end;local q=1;local R=P;while q<#O do if R[O[q]]==nil then return false end;R=R[O[q]]q=q+1 end;if Q==nil then return R[O[q]]else R[O[q]]=Q;return true end end;local function S(P,T)T=T or 0;for U,V in pairs(P)do if type(V)=="table"then if V[1]==-1 then T=S(V,T)else T=T+V[1]end end end;return T end;local function W(O,P,X)if X>#O then return true end;local Y={}local q=0;while q<X do table.insert(Y,O[q+1])q=q+1 end;dir=N(Y,P)if dir==false then N(Y,P,{-1,K()})end;return W(O,P,X+1)end;local function Z(_,a0,a1)for d,a2 in pairs(_)do if type(d)~='number'then if a2[1]==-1 then local a3=A(a1)table.insert(a3,d)local a4=N(a3,a0[1])if not a4 then return a4 end;if not Z(a4,a0,a3)then return false end else for U,a5 in pairs(_[3])do table.insert(a0[2],a5)end end end end;N(a1,a0[1],nil)return true end;local function a6(a7,a8)local q=0;local a9=0;while q<#a7 do q=q+1;local aa=a9;a9=a9+a7[q][2]-a7[q][1]if aa<=a8 and a9>=a8 then return q end end;return false end;local function ab(ac,ad,_)local a9=0;while ac<=ad do a9=a9+_[3][ac][2]-_[3][ac][1]ac=ac+1 end;return a9 end;local function ae(af,ag)if af[1]<ag[1]then return true else return false end end;local ah,ai;if computer.getArchitecture()=="Lua 5.3"then ah,ai=load([[return function(a)local b,c=1,{}local d=''local function e()for f=18,3,-1 do local g=string.sub(a,b,b+f-1)local h=string.find(d,g,1,true)if h then return h,g end end end;while b<=#a do local i,j=0,{}for f=0,7 do if b<=#a then local h,g=e()if h and#g>=3 then local k=h-1<<4|#g-3;j[#j+1]=string.pack('>I2',k)else i=i|(1<<f)g=string.sub(a,b,b)j[#j+1]=g end;d=string.sub(d..g,-4096)b=b+#g else break end end;if#j>0 then c[#c+1]=string.char(i)c[#c+1]=table.concat(j)end end;return table.concat(c)end,function(a)local b,c=1,{}local d=''while b<=#a do local i=string.byte(a,b)b=b+1;for f=1,8 do local g=nil;if i&1~=0 then if b<=#a then g=string.sub(a,b,b)b=b+1 end else if b+1<=#a then local k=string.unpack('>I2',a,b)b=b+2;local h=k>>4+1;local l=k&15+3;g=string.sub(d,h,h+l-1)end end;i=i>>1;if g then c[#c+1]=g;d=string.sub(d..g,-4096)end end end;return table.concat(c)end]])()end;local aj={}function aj.proxy(ak)local al=false;for d,s in component.list("tape_drive")do if d==ak and s=="tape_drive"then al=true;break end end;if not al then error("No such component",2)end;local am;component.invoke(ak,"seek",-math.huge)local an={}an.type="filesystem"an.address=ak:gsub("-","").."-tap"an.isReady=function()return component.invoke(ak,"isReady")end;an.setDriveProperty=function(ao,g)checkArg(1,ao,"string")checkArg(2,g,"number","string","boolean")if b[ao]==nil then return nil,'Invalid property'end;b[ao]=g;return true end;an.getDriveProperty=function(ao)checkArg(1,ao,"string")if b[ao]==nil then return nil,'Invalid property'end;return b[ao]end;an.getTable=function()if not an.isReady()then error('Device is not ready')end;component.invoke(ak,"seek",-math.huge)local ap=component.invoke(ak,"read",8192)local aq;if ap:sub(0,2)=="{{"then aq=ap:match("[^\0]+")elseif ap:sub(3,4)=="\120\156"then if not component.isAvailable('data')then error('inflate: Data card required')end;aq=component.data.inflate(string.unpack('s2',ap))else if not ai then error('LZSS decompression: Lua 5.3 required')end;aq=ai(string.unpack('s2',ap))end;if not aq or aq==""then error('FAT corrupted: table not found')end;local ar,as=v(aq)if not ar then error('FAT corrupted: '..(as or'unknown reason'))else return ar end end;an.setTable=function(at)checkArg(1,at,"table")if not an.isReady()then error('Device is not ready')end;local au=f(at)if b.tabcom==1 then if not ah then error('LZSS compression: Lua 5.3 required')end;au=string.pack('s2',ah(au))elseif b.tabcom==2 then if not component.isAvailable('data')then error('deflate: Data card required')end;au=string.pack('s2',component.data.deflate(au))end;if#au>8192 then return nil,'Not enough space for FAT'end;if#au~=8192 then au=au.."\0"end;component.invoke(ak,"seek",-math.huge)component.invoke(ak,"write",au)return#au end;an.format=function(av)av=av or false;checkArg(1,av,"boolean")if not an.isReady()then error('Device is not ready')end;local aw=component.invoke(ak,"getSize")if not av then component.invoke(ak,"seek",-math.huge)local ax=string.rep("\0",8192)for q=1,aw+8191,8192 do component.invoke(ak,"write",ax)end end;local ay,as=an.setTable({{},{{8192,math.ceil(aw)-1}}})if not ay then return ay,as else return true end end;an.isDirectory=function(E)checkArg(1,E,"string")if not an.isReady()then error('Device is not ready')end;E=J(E)if E==''then return true end;local a1=D(E)local a0=an.getTable()local az=N(a1,a0[1])if type(az)~='table'then return false end;if az[1]==-1 then return true else return false end end;an.lastModified=function(E)checkArg(1,E,"string")E=J(E)if not an.isReady()then error('Device is not ready')end;local a0=an.getTable()local a1=D(E)local _=N(a1,a0[1])if not _ then return 0 end;return _[2]end;an.list=function(E)checkArg(1,E,"string")E=J(E)if not an.isReady()then error('Device is not ready')end;local a0=an.getTable()local a1=D(E)local aA=N(a1,a0[1])if aA==false then return nil,'no such file or directory: '..E end;local az={}if aA[1]~=-1 and#a1~=0 then return{a1[#a1],n=1}end;for d,C in pairs(aA)do if type(d)~='number'then if C[1]==-1 then table.insert(az,d..'/')else table.insert(az,d)end end end;az.n=#az;return az end;an.spaceTotal=function()if not an.isReady()then error('Device is not ready')end;return component.invoke(ak,"getSize")-8193 end;an.open=function(E,aB)aB=aB or'r'checkArg(1,E,"string")checkArg(2,aB,"string")if not an.isReady()then error('Device is not ready')end;local aC;local a0=an.getTable()local a1=D(E)if aB~="r"and aB~="rb"and aB~="w"and aB~="wb"and aB~="a"and aB~="ab"then error("unsupported mode",2)end;local aD=true;while aD do aC=math.random(1000000000,9999999999)if a[aC]==nil then if aB=="r"or aB=="rb"then local aE=N(a1,a0[1])if not aE or aE[1]==-1 then return nil,E end;a[aC]={seek=0,mode='r',path=a1}elseif aB=="w"or aB=="wb"then a[aC]={seek=0,mode='w',path=a1}local aE=N(a1,a0[1])if aE then for U,aF in pairs(aE[3])do table.insert(a0[2],aF)end;table.sort(a0[2],ae)local aG=1;while aG<#a0[2]do if a0[2][aG][2]==a0[2][aG+1][1]then a0[2][aG][2]=a0[2][aG+1][2]table.remove(a0[2],aG+1)else aG=aG+1 end end elseif#a0[2]==0 then return nil,"not enough space"end;if not N(a1,a0[1],{0,K(),{}})then return false end elseif aB=="a"or aB=="ab"then local aE=N(a1,a0[1])local aH;if not aE then if not N(a1,a0[1],{0,K(),{}})then return false end else aH=aE[1]+1 end;a[aC]={seek=aH,mode='a',path=a1}end;aD=false end end;if aB=="a"or aB=="ab"or aB=="w"or aB=="wb"then local ay,as=an.setTable(a0)if not ay then return ay,as else return aC end else return aC end end;an.remove=function(E)checkArg(1,E,"string")if not an.isReady()then error('Device is not ready')end;E=J(E)if E==''then return false end;local a0=an.getTable()local a1=D(E)local _=N(a1,a0[1])if _==false then return false end;if _[1]==-1 then Z(_,a0,a1)else for U,a5 in pairs(_[3])do table.insert(a0[2],a5)end;N(a1,a0[1],nil)end;table.sort(a0[2],ae)local aG=1;while aG<#a0[2]do if a0[2][aG][2]==a0[2][aG+1][1]then a0[2][aG][2]=a0[2][aG+1][2]table.remove(a0[2],aG+1)else aG=aG+1 end end;local ay,as=an.setTable(a0)if not ay then return ay,as else return true end end;an.rename=function(E,aI)checkArg(1,E,"string")checkArg(1,aI,"string")if not an.isReady()then error('Device is not ready')end;E=J(E)local a0=an.getTable()local a1=D(E)local aJ=D(aI)local _=N(a1,a0[1])local aK=N(aJ,a0[1])if not _ or aK then return false end;if _[1]~=-1 then aJ=D(aI)end;N(a1,a0[1],nil)N(aJ,a0[1],_)if not N(aJ,a0[1],_)then return false end;local ay,as=an.setTable(a0)if not ay then return ay,as else return true end end;an.read=function(aL,aM)aM=aM or 1;checkArg(1,aL,"number")checkArg(2,aM,"number")if not an.isReady()then error('Device is not ready')end;if a[aL]==nil or a[aL].mode~="r"then return nil,"bad file descriptor"end;local a0=an.getTable()local _=N(a[aL].path,a0[1])if not _ then a[aL]=nil;return nil,"bad file descriptor"end;if _[1]==0 or _[1]<a[aL].seek+1 then return nil end;if _[1]>=a[aL].seek+1 and _[1]<a[aL].seek+aM then aM=_[1]-a[aL].seek end;component.invoke(ak,"seek",-math.huge)local aN=a6(_[3],a[aL].seek)local aO=a6(_[3],a[aL].seek+aM)if not aO then aO=#_[3]end;component.invoke(ak,"seek",_[3][aN][1]+a[aL].seek-ab(1,aN-1,_))local w=component.invoke(ak,"read",_[3][aN][2]-_[3][aN][1])aN=aN+1;while aN<aO+1 do component.invoke(ak,"seek",-math.huge)component.invoke(ak,"seek",_[3][aN][1])w=w..component.invoke(ak,"read",_[3][aN][2]-_[3][aN][1])aN=aN+1 end;w=w:sub(0,aM)a[aL].seek=a[aL].seek+#w;return w end;an.close=function(aL)checkArg(1,aL,"number")if not an.isReady()then error('Device is not ready')end;if a[aL]==nil then return nil,"bad file descriptor"end;a[aL]=nil end;an.getLabel=function()if not an.isReady()then error('Device is not ready')end;return component.invoke(ak,"getLabel")end;an.seek=function(aL,aP,aQ)checkArg(1,aL,"number")checkArg(2,aP,"string")checkArg(3,aQ,"number")if not an.isReady()then error('Device is not ready')end;if a[aL]==nil then return nil,"bad file descriptor"end;if aP~="set"and aP~="cur"and aP~="end"then error("invalid mode",2)end;if aQ<0 then return nil,"Negative seek offset"end;local aR;if aP=="set"then aR=aQ elseif aP=="cur"then aR=a[aL].seek+aQ elseif aP=="end"then aR=component.invoke(ak,"getSize")+aQ-1 end;a[aL].seek=math.min(math.max(aR,0),component.invoke(ak,"getSize")-1)return a[aL].seek end;an.size=function(E)checkArg(1,E,"string")if not an.isReady()then error('Device is not ready')end;E=J(E)if E==''then return 0 end;local a0=an.getTable()local a1=D(E)local _=N(a1,a0[1])if not _ or _[1]==-1 then return 0 end;return _[1]end;an.isReadOnly=function()if not an.isReady()then error('Device is not ready')end;return false end;an.setLabel=function(aS)if not an.isReady()then error('Device is not ready')end;component.invoke(ak,"setLabel",aS)return aS end;an.makeDirectory=function(E)checkArg(1,E,"string")if not an.isReady()then error('Device is not ready')end;E=J(E)local a0=an.getTable()local a1=D(E)W(a1,a0[1],1)local ay,as=an.setTable(a0)if not ay then return ay,as else return true end end;an.exists=function(E)checkArg(1,E,"string")if not an.isReady()then error('Device is not ready')end;E=J(E)if E==''then return true end;local a1=D(E)local a0=an.getTable()local az=N(a1,a0[1])if az then return true else return az end end;an.spaceUsed=function()if not an.isReady()then error('Device is not ready')end;return S(an.getTable()[1])end;an.write=function(aL,w)checkArg(1,aL,"number")checkArg(2,w,"string")if not an.isReady()then error('Device is not ready')end;if a[aL]==nil or a[aL].mode=="r"then return nil,"bad file descriptor"end;local a0=an.getTable()if#a0[2]==0 then return nil,"not enough space"end;local a1=a[aL].path;local _=N(a1,a0[1])a[aL].seek=a[aL].seek+#w;if a[aL].seek>_[1]or#_[3]==0 then _[1]=_[1]+#w;while true do if#a0[2]==0 then _[1]=ab(1,#_[3],_)local ay,as=an.setTable(a0)if not ay then return ay,as else return true end elseif a0[2][1][2]-a0[2][1][1]<#w then table.insert(_[3],{a0[2][1][1],a0[2][1][2]})component.invoke(ak,"seek",-math.huge)component.invoke(ak,"seek",a0[2][1][1])component.invoke(ak,"write",w:sub(0,a0[2][1][2]-a0[2][1][1]))w=w:sub(a0[2][1][2]-a0[2][1][1]+1)table.remove(a0[2],1)else table.insert(_[3],{a0[2][1][1],a0[2][1][1]+#w})component.invoke(ak,"seek",-math.huge)component.invoke(ak,"seek",a0[2][1][1])component.invoke(ak,"write",w)if a0[2][1][1]+#w==a0[2][1][2]then table.remove(a0[2],1)else a0[2][1][1]=a0[2][1][1]+#w end;break end end elseif a[aL].seek+#w>_[1]then _[1]=a[aL].seek+#w;local aN=a6(_[3],a[aL].seek)local aO=#_[3]if not aO then aO=#_[3]end;component.invoke(ak,"seek",_[3][aN][1]+a[aL].seek-ab(1,aN-1,_))component.invoke(ak,"write",w:sub(0,_[3][aN][2]-_[3][aN][1]))w=w:sub(_[3][aN][2]-_[3][aN][1])aN=aN+1;while aN<aO+1 do component.invoke(ak,"seek",-math.huge)component.invoke(ak,"seek",_[3][aN][1])component.invoke(ak,"write",w:sub(0,_[3][aN][2]-_[3][aN][1]))w=w:sub(_[3][aN][2]-_[3][aN][1]+1)aN=aN+1 end;while true do if#a0[2]==0 then _[1]=ab(1,#_[3],_)local ay,as=an.setTable(a0)if not ay then return ay,as else return true end elseif a0[2][1][2]-a0[2][1][1]<#w then table.insert(_[3],{a0[2][1][1],a0[2][1][2]})component.invoke(ak,"seek",-math.huge)component.invoke(ak,"seek",a0[2][1][1])component.invoke(ak,"write",w:sub(0,a0[2][1][2]-a0[2][1][1]))w=w:sub(a0[2][1][2]-a0[2][1][1]+1)table.remove(a0[2],1)else table.insert(_[3],{a0[2][1][1],a0[2][1][1]+#w})component.invoke(ak,"seek",-math.huge)component.invoke(ak,"seek",a0[2][1][1])component.invoke(ak,"write",w)if a0[2][1][1]+#w==a0[2][1][2]then table.remove(a0[2],1)else a0[2][1][1]=a0[2][1][1]+#w end;break end end else local aN=a6(_[3],a[aL].seek)local aO=a6(_[3],a[aL].seek+#w)if not aO then aO=#_[3]end;component.invoke(ak,"seek",_[3][aN][1]+a[aL].seek-ab(1,aN-1,_))component.invoke(ak,"write",w:sub(0,_[3][aN][2]-_[3][aN][1]))w=w:sub(_[3][aN][2]-_[3][aN][1])aN=aN+1;while aN<aO+1 do component.invoke(ak,"seek",-math.huge)component.invoke(ak,"seek",_[3][aN][1])component.invoke(ak,"write",w:sub(0,_[3][aN][2]-_[3][aN][1]))w=w:sub(_[3][aN][2]-_[3][aN][1]+1)aN=aN+1 end end;local aG=1;while aG<#_[3]do if _[3][aG][2]==_[3][aG+1][1]then _[3][aG][2]=_[3][aG+1][2]table.remove(_[3],aG+1)else aG=aG+1 end end;N(a1,a0[1],_)local ay,as=an.setTable(a0)if not ay then return ay,as else return true end end;return an end;local aT=aj.proxy(component.list('tape_drive')())local aU=component.proxy;function component.proxy(ak)checkArg(1,ak,"string")if aT.address==ak then return aT end;return aU(ak)end;local aV=component.list;function component.list(aW,aX)local aY=aV(aW,aX)if aW==nil or aX and aW=='filesystem'or not aX and('filesystem'):find(aW,nil,true)then aY[aT.address]='filesystem'end;return aY end;local aZ=component.invoke;function component.invoke(ak,a_,...)checkArg(1,ak,"string")checkArg(2,a_,"string")if aT.address==ak then if aT[a_]==nil then error("no such method",2)end;return aT[a_](...)end;return aZ(ak,a_,...)end